VB中的AddressOf操作符可以取得函数的地址（主要是回调函数），但是有时候使用不当会产生编译错误。我发现这个函数必须定义在一个模块中，不能在窗口代码里。下面是MSDN中的一点说明。
一个一元运算符，它将其后面的过程的地址传递给一个 API 过程，该 API 过程在参数表对应位置中需要一个函数指针。

语法
AddressOf procedurename

参数		类型及说明
procedurename	必需的。指定要传递的地址是哪一个过程的地址。这个过程必须是发出调用命令的工程中的一个标准模块模块里的一个过程。

说明
当一个过程的名称出现在一个参数列表中时，通常该过程已经被计算，并且该过程返回值的地址也会被传递。AddressOf 允许该过程的地址被传递给动态链接库 (DLL) 中的一个 Windows API 函数，而不是传递该过程的返回值。API 函数然后就可以使用这个地址来调用相应的 Basic 过程，这个过程就是我们所知道的回调。AddressOf 运算符只出现在对 API 过程的调用中。

尽管可以使用 AddressOf 运算符在 Basic 过程之间传递过程指针，却不能通过这样的一个指针从 Basic 内部调用一个函数。这就是说，例如，一个使用 Basic 编写的类 不能使用这样的一个指针来回调自己的控制器。当使用 AddressOf 运算符在 Basic 内的过程之间传递一个过程的指针时，被调用过程的参数类型必须定义为 As Long。

警告
如果不能完全理解函数回调的概念，则使用 AddressOf 运算符可能会导致意想不到的结果。必须理解回调的 Basic 部份是如何工作的，以及接受所传递的函数地址的 DLL 的代码是如何工作的。调试这样的交互操作是非常困难的，因为该程序和开发环境运行在相同的进程中。在某些情况下，系统的调试也许是不可能的。

注意
可以使用 Microsoft Visual C++ （或者类似的工具）编译的 DLLs 来创建自己的回调函数原型。要使用 AddressOf 运算符来工作，您的原型必需使用 __stdcall 调用约定。缺省的调用约定 (__cdecl) 不能与 AddressOf 运算符一起工作。

因为一个回调的调用程序不在用户自己的程序中，所以很重要的一点是要保证回调过程中的错误不被回传到调用者。可以通过把 On Error Resume Next 语句放置于回调过程的起始处来达到这个要求。
